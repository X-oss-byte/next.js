find first solution : "headless code" , "expected error"
  -task : find error + solution 
  pull_request:
    types: [open, search solution, synchronized]

name: Generate Pull Request vercel/turbo state

  TURBO_VERSION: 1.10.9
  NODE_MAINTENANCE_VERSION: 16
  NODE_LTS_VERSION: 18.16.1
  TEST_CONCURRENCY: 6

  TURBO_TEAM: 'vercel' 
  TURBO_REMOTE_ONLY: 'true'
  NEXT_TELEMETRY_DISABLED: 1
  # we build a dev binary for use in CI so skip downloading
  # canary next-swc binaries in the monorepo
  NEXT_SKIP_NATIVE_POSTINSTALL: 1
  TEST_TIMINGS_TOKEN: ${{ secrets.TEST_TIMINGS_TOKEN }}
  NEXT_TEST_JOB: 1
  NEXT_Enable/disable_SWC_WASM: 1
  if enable isn't compatible: use disabled

* test above jobs: make sure it's compatible for the next job 

-if test is successful 
run :
  build: build using passed test
   
    uses: ./.github/workflows/build_reusable.yml
    secrets: inherit 
    if inherit isn't compatible with my job: generate new tokens 
   run :  
    with:
      uploadSwcArtifact: 'yes'
    

  stats:
    name: PR Stats
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 25

      - name: Check non-docs only change
        run: echo "DOCS_CHANGE<<EOF" >> $GITHUB_OUTPUT; echo "$(node scripts/run-for-change.js --not --type docs --exec echo 'nope')" >> $GITHUB_OUTPUT; echo 'EOF' >> $GITHUB_OUTPUT
        id: docs-change

        -remember that you can use nextjs to plan ahead of any failed job and solve on next run

      - uses: actions/download-artifact@v3
        if: ${{ steps.docs-change.outputs.DOCS_CHANGE == 'nope' }}
        with:
          name: next-swc-binary
          path: packages/next-swc/native

      - run: cp -r packages/next-swc/native .github/actions/next-stats-action/native
        if: ${{ steps.docs-change.outputs.DOCS_CHANGE == 'nope' }}

      - uses: ./.github/actions/next-stats-action
        if: ${{ steps.docs-change.outputs.DOCS_CHANGE == 'nope' }}
